from sys import maxint as MAXINT
from collections import OrderedDict
from time import time
import shared
TOKEN_CACHE_TIME = 0  # tokens are valid for 15 minutes
STREAM_DATA = 'https://api.twitch.tv/kraken/streams/{channel_name}'
STREAM_TOKEN = 'https://api.twitch.tv/api/channels/{channel_name}/access_token'
STREAM_URL = ('http://usher.twitch.tv/api/channel/hls/{channel_name}.m3u8'
              '?token={token}&sig={sig}&allow_source=true')
VOD_DATA = 'https://api.twitch.tv/kraken/videos/{vod_type}{vod_id}'
VOD_TOKEN = 'https://api.twitch.tv/api/vods/{vod_id}/access_token'
VOD_URL = ('http://usher.twitch.tv/vod/{vod_id}'
           '?nauth={token}&nauthsig={sig}&allow_source=true')
ACCEPTED_VOD_TYPES = ["v"]
# arbitrary resolution values so the client can distinguish them
HLS_RESOLUTIONS = OrderedDict([("Source", 1080),
                               ("High", 720),
                               ("Medium", 480),
                               ("Low", 360),
                               ("Mobile", 226)])


def NormalizeURL(url):
    return url.split('?')[0].split('#')[0].rstrip('/')


def MetadataObjectForURL(url):
    if is_stream(url):
        user_id = get_user_id(url)
        try:
            video = JSON.ObjectFromURL(STREAM_DATA.format(channel_name=user_id), cacheTime=0)
        except Exception:
            raise Ex.MediaNotAvailable
        else:
            if video['stream'] is None:
                raise Ex.LiveMediaNotStarted
            stream_info = video['stream']
            channel_info = stream_info['channel']
        # make the thumbnail only valid for ~100 seconds
        thumb = "{}?t={:.0f}".format(stream_info['preview']['large'], round(time(), -2))
        return VideoClipObject(
            title=unicode('{} - {}'.format(channel_info['display_name'],
                                           channel_info.get('game', '?'))),
            summary=unicode('{}\n\n{} viewers'.format(channel_info.get('status', '?'),
                                                      stream_info['viewers'])),
            thumb=Resource.ContentsOfURLWithFallback(thumb)
        )
    elif is_vod(url):
        vod_id = get_vod_id(url)
        vod_type = get_vod_type(url)
        try:
            video = JSON.ObjectFromURL(VOD_DATA.format(vod_type=vod_type, vod_id=vod_id),
                                       cacheTime=0)
        except Exception:
            raise Ex.MediaNotAvailable
        else:
            if 'error' in video:
                raise Ex.MediaNotAvailable
        return VideoClipObject(
            title=unicode(video['title']),
            summary=unicode(video['description']),
            thumb=Resource.ContentsOfURLWithFallback(video['preview']),
            duration=min(int(video['length']) * 1000, MAXINT)
        )
    else:
        raise Ex.MediaNotAvailable


def MediaObjectsForURL(url):
    quality_option = (Prefs['stream_quality_selection'] if is_stream(url) else
                      Prefs['vod_quality_selection'])
    if is_vod(url):
        if get_vod_type(url) not in ACCEPTED_VOD_TYPES:
            raise Ex.MediaNotAvailable
    if quality_option == "Manual":
        return [
            MediaObject(
                protocol='hls',
                container='mpegts',
                video_codec=VideoCodec.H264,
                audio_codec=AudioCodec.AAC,
                audio_channels=2,
                optimized_for_streaming=True,
                video_resolution=resolution,
                parts=[PartObject(key=Callback(PlayHLS, url=url, quality=quality, ext='m3u8'))]
            ) for quality, resolution in HLS_RESOLUTIONS.iteritems()
        ]
    elif quality_option in HLS_RESOLUTIONS:  # explicit quality selection
        return [
            MediaObject(
                protocol='hls',
                container='mpegts',
                video_codec=VideoCodec.H264,
                audio_codec=AudioCodec.AAC,
                audio_channels=2,
                optimized_for_streaming=True,
                video_resolution=HLS_RESOLUTIONS[quality_option],
                parts=[PartObject(key=Callback(PlayHLS, url=url,
                                               quality=quality_option, ext='m3u8'))]
            )
        ]
    else:  # automatic (let plex handle it)
        return [
            MediaObject(
                protocol='hls',
                container='mpegts',
                video_codec=VideoCodec.H264,
                audio_codec=AudioCodec.AAC,
                audio_channels=2,
                optimized_for_streaming=True,
                parts=[PartObject(key=Callback(PlayHLS, url=url, ext='m3u8'))]
            )
        ]


@indirect
def PlayHLS(url, quality=None, **kwargs):
    url, access_token = shared.parse_service_url(url)

    if is_stream(url):
        user_id = get_user_id(url)
        try:  # get a token
            turl = STREAM_TOKEN.format(channel_name=user_id)
            if access_token is not None:
                turl += '?oauth_token=' + access_token
            token = JSON.ObjectFromURL(turl, cacheTime=TOKEN_CACHE_TIME)
            Log.Debug('token: {}'.format(token))
        except Exception as e:
            Log.Error('TWITCH: PlayHLS: {}'.format(e))
            raise Ex.MediaNotAvailable
        else:
            final_url = STREAM_URL.format(channel_name=user_id,
                                          token=String.Quote(token['token']),
                                          sig=String.Quote(token['sig']))
    elif is_vod(url):
        vod_id = get_vod_id(url)
        try:  # get a token
            turl = VOD_TOKEN.format(vod_id=vod_id)
            if access_token is not None:
                turl += '?oauth_token=' + access_token
            token = JSON.ObjectFromURL(turl, cacheTime=TOKEN_CACHE_TIME)
            Log.Debug('token: {}'.format(token))
        except Exception as e:
            Log.Error('TWITCH: PlayHLS: {}'.format(e))
            raise Ex.MediaNotAvailable
        else:
            final_url = VOD_URL.format(vod_id=vod_id,
                                       token=String.Quote(token['token']),
                                       sig=String.Quote(token['sig']))
    else:
        raise Ex.MediaNotAvailable

    if quality is not None:
        Log("TWITCH: Quality = " + quality)
        playlist_contents = HTTP.Request(final_url, cacheTime=0).content
        final_url = get_twitch_quality(playlist_contents, quality)

    Log("TWITCH: Final Url = " + final_url)
    return IndirectResponse(VideoClipObject, key=HTTPLiveStreamURL(final_url))

################################################################################


def is_stream(url):
    return len(url.split('/')) == 4


def is_vod(url):
    return len(url.split('/')) == 6


def get_user_id(url):
    return url.split('/')[-1]


def get_vod_id(url):
    return url.split('/')[-1]


def get_vod_type(url):
    return url.split('/')[-2]


def parse_m3u(playlist):
    parsed = {}
    lines = playlist.splitlines()
    for i, line in enumerate(lines):
        if not line.startswith('#EXT-X-MEDIA'):
            continue
        name_pos = line.find('NAME="')
        if name_pos < 0:
            continue
        name = line[name_pos + 6:].split('"')[0]
        url = lines[i + 2] if i + 2 < len(lines) else None
        parsed[name] = url
    return parsed


def get_twitch_quality(playlist, quality):
    parsed = parse_m3u(playlist)
    Log("TWITCH: Playlists = " + repr(parsed))
    if quality in parsed:
        Log("TWITCH: Quality is available. url = " + parsed[quality])
        return parsed[quality]
    else:
        available = {v: k for k, v in HLS_RESOLUTIONS.iteritems() if k in parsed}
        best_match = available[min(available.keys(),
                                   key=lambda x: abs(x - HLS_RESOLUTIONS[quality]))]
        Log("TWITCH: Quality is not available. Best match = " + best_match)
        return parsed[best_match]
